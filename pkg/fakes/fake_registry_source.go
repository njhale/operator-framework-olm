// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	sync "sync"

	v1alpha1 "github.com/operator-framework/operator-lifecycle-manager/pkg/api/apis/operators/v1alpha1"
	registry "github.com/operator-framework/operator-lifecycle-manager/pkg/controller/registry"
	v1beta1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1beta1"
)

type FakeSource struct {
	AllPackagesStub        func() map[string]registry.PackageManifest
	allPackagesMutex       sync.RWMutex
	allPackagesArgsForCall []struct {
	}
	allPackagesReturns struct {
		result1 map[string]registry.PackageManifest
	}
	allPackagesReturnsOnCall map[int]struct {
		result1 map[string]registry.PackageManifest
	}
	FindCRDByKeyStub        func(registry.CRDKey) (*v1beta1.CustomResourceDefinition, error)
	findCRDByKeyMutex       sync.RWMutex
	findCRDByKeyArgsForCall []struct {
		arg1 registry.CRDKey
	}
	findCRDByKeyReturns struct {
		result1 *v1beta1.CustomResourceDefinition
		result2 error
	}
	findCRDByKeyReturnsOnCall map[int]struct {
		result1 *v1beta1.CustomResourceDefinition
		result2 error
	}
	FindCSVByNameStub        func(string) (*v1alpha1.ClusterServiceVersion, error)
	findCSVByNameMutex       sync.RWMutex
	findCSVByNameArgsForCall []struct {
		arg1 string
	}
	findCSVByNameReturns struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	findCSVByNameReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	FindCSVForPackageNameUnderChannelStub        func(string, string) (*v1alpha1.ClusterServiceVersion, error)
	findCSVForPackageNameUnderChannelMutex       sync.RWMutex
	findCSVForPackageNameUnderChannelArgsForCall []struct {
		arg1 string
		arg2 string
	}
	findCSVForPackageNameUnderChannelReturns struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	findCSVForPackageNameUnderChannelReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	FindReplacementCSVForNameStub        func(string) (*v1alpha1.ClusterServiceVersion, error)
	findReplacementCSVForNameMutex       sync.RWMutex
	findReplacementCSVForNameArgsForCall []struct {
		arg1 string
	}
	findReplacementCSVForNameReturns struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	findReplacementCSVForNameReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	FindReplacementCSVForPackageNameUnderChannelStub        func(string, string, string) (*v1alpha1.ClusterServiceVersion, error)
	findReplacementCSVForPackageNameUnderChannelMutex       sync.RWMutex
	findReplacementCSVForPackageNameUnderChannelArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	findReplacementCSVForPackageNameUnderChannelReturns struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	findReplacementCSVForPackageNameUnderChannelReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	ListLatestCSVsForCRDStub        func(registry.CRDKey) ([]registry.CSVAndChannelInfo, error)
	listLatestCSVsForCRDMutex       sync.RWMutex
	listLatestCSVsForCRDArgsForCall []struct {
		arg1 registry.CRDKey
	}
	listLatestCSVsForCRDReturns struct {
		result1 []registry.CSVAndChannelInfo
		result2 error
	}
	listLatestCSVsForCRDReturnsOnCall map[int]struct {
		result1 []registry.CSVAndChannelInfo
		result2 error
	}
	ListServicesStub        func() ([]v1alpha1.ClusterServiceVersion, error)
	listServicesMutex       sync.RWMutex
	listServicesArgsForCall []struct {
	}
	listServicesReturns struct {
		result1 []v1alpha1.ClusterServiceVersion
		result2 error
	}
	listServicesReturnsOnCall map[int]struct {
		result1 []v1alpha1.ClusterServiceVersion
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSource) AllPackages() map[string]registry.PackageManifest {
	fake.allPackagesMutex.Lock()
	ret, specificReturn := fake.allPackagesReturnsOnCall[len(fake.allPackagesArgsForCall)]
	fake.allPackagesArgsForCall = append(fake.allPackagesArgsForCall, struct {
	}{})
	fake.recordInvocation("AllPackages", []interface{}{})
	fake.allPackagesMutex.Unlock()
	if fake.AllPackagesStub != nil {
		return fake.AllPackagesStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.allPackagesReturns
	return fakeReturns.result1
}

func (fake *FakeSource) AllPackagesCallCount() int {
	fake.allPackagesMutex.RLock()
	defer fake.allPackagesMutex.RUnlock()
	return len(fake.allPackagesArgsForCall)
}

func (fake *FakeSource) AllPackagesCalls(stub func() map[string]registry.PackageManifest) {
	fake.allPackagesMutex.Lock()
	defer fake.allPackagesMutex.Unlock()
	fake.AllPackagesStub = stub
}

func (fake *FakeSource) AllPackagesReturns(result1 map[string]registry.PackageManifest) {
	fake.allPackagesMutex.Lock()
	defer fake.allPackagesMutex.Unlock()
	fake.AllPackagesStub = nil
	fake.allPackagesReturns = struct {
		result1 map[string]registry.PackageManifest
	}{result1}
}

func (fake *FakeSource) AllPackagesReturnsOnCall(i int, result1 map[string]registry.PackageManifest) {
	fake.allPackagesMutex.Lock()
	defer fake.allPackagesMutex.Unlock()
	fake.AllPackagesStub = nil
	if fake.allPackagesReturnsOnCall == nil {
		fake.allPackagesReturnsOnCall = make(map[int]struct {
			result1 map[string]registry.PackageManifest
		})
	}
	fake.allPackagesReturnsOnCall[i] = struct {
		result1 map[string]registry.PackageManifest
	}{result1}
}

func (fake *FakeSource) FindCRDByKey(arg1 registry.CRDKey) (*v1beta1.CustomResourceDefinition, error) {
	fake.findCRDByKeyMutex.Lock()
	ret, specificReturn := fake.findCRDByKeyReturnsOnCall[len(fake.findCRDByKeyArgsForCall)]
	fake.findCRDByKeyArgsForCall = append(fake.findCRDByKeyArgsForCall, struct {
		arg1 registry.CRDKey
	}{arg1})
	fake.recordInvocation("FindCRDByKey", []interface{}{arg1})
	fake.findCRDByKeyMutex.Unlock()
	if fake.FindCRDByKeyStub != nil {
		return fake.FindCRDByKeyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findCRDByKeyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSource) FindCRDByKeyCallCount() int {
	fake.findCRDByKeyMutex.RLock()
	defer fake.findCRDByKeyMutex.RUnlock()
	return len(fake.findCRDByKeyArgsForCall)
}

func (fake *FakeSource) FindCRDByKeyCalls(stub func(registry.CRDKey) (*v1beta1.CustomResourceDefinition, error)) {
	fake.findCRDByKeyMutex.Lock()
	defer fake.findCRDByKeyMutex.Unlock()
	fake.FindCRDByKeyStub = stub
}

func (fake *FakeSource) FindCRDByKeyArgsForCall(i int) registry.CRDKey {
	fake.findCRDByKeyMutex.RLock()
	defer fake.findCRDByKeyMutex.RUnlock()
	argsForCall := fake.findCRDByKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSource) FindCRDByKeyReturns(result1 *v1beta1.CustomResourceDefinition, result2 error) {
	fake.findCRDByKeyMutex.Lock()
	defer fake.findCRDByKeyMutex.Unlock()
	fake.FindCRDByKeyStub = nil
	fake.findCRDByKeyReturns = struct {
		result1 *v1beta1.CustomResourceDefinition
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindCRDByKeyReturnsOnCall(i int, result1 *v1beta1.CustomResourceDefinition, result2 error) {
	fake.findCRDByKeyMutex.Lock()
	defer fake.findCRDByKeyMutex.Unlock()
	fake.FindCRDByKeyStub = nil
	if fake.findCRDByKeyReturnsOnCall == nil {
		fake.findCRDByKeyReturnsOnCall = make(map[int]struct {
			result1 *v1beta1.CustomResourceDefinition
			result2 error
		})
	}
	fake.findCRDByKeyReturnsOnCall[i] = struct {
		result1 *v1beta1.CustomResourceDefinition
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindCSVByName(arg1 string) (*v1alpha1.ClusterServiceVersion, error) {
	fake.findCSVByNameMutex.Lock()
	ret, specificReturn := fake.findCSVByNameReturnsOnCall[len(fake.findCSVByNameArgsForCall)]
	fake.findCSVByNameArgsForCall = append(fake.findCSVByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindCSVByName", []interface{}{arg1})
	fake.findCSVByNameMutex.Unlock()
	if fake.FindCSVByNameStub != nil {
		return fake.FindCSVByNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findCSVByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSource) FindCSVByNameCallCount() int {
	fake.findCSVByNameMutex.RLock()
	defer fake.findCSVByNameMutex.RUnlock()
	return len(fake.findCSVByNameArgsForCall)
}

func (fake *FakeSource) FindCSVByNameCalls(stub func(string) (*v1alpha1.ClusterServiceVersion, error)) {
	fake.findCSVByNameMutex.Lock()
	defer fake.findCSVByNameMutex.Unlock()
	fake.FindCSVByNameStub = stub
}

func (fake *FakeSource) FindCSVByNameArgsForCall(i int) string {
	fake.findCSVByNameMutex.RLock()
	defer fake.findCSVByNameMutex.RUnlock()
	argsForCall := fake.findCSVByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSource) FindCSVByNameReturns(result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findCSVByNameMutex.Lock()
	defer fake.findCSVByNameMutex.Unlock()
	fake.FindCSVByNameStub = nil
	fake.findCSVByNameReturns = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindCSVByNameReturnsOnCall(i int, result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findCSVByNameMutex.Lock()
	defer fake.findCSVByNameMutex.Unlock()
	fake.FindCSVByNameStub = nil
	if fake.findCSVByNameReturnsOnCall == nil {
		fake.findCSVByNameReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterServiceVersion
			result2 error
		})
	}
	fake.findCSVByNameReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindCSVForPackageNameUnderChannel(arg1 string, arg2 string) (*v1alpha1.ClusterServiceVersion, error) {
	fake.findCSVForPackageNameUnderChannelMutex.Lock()
	ret, specificReturn := fake.findCSVForPackageNameUnderChannelReturnsOnCall[len(fake.findCSVForPackageNameUnderChannelArgsForCall)]
	fake.findCSVForPackageNameUnderChannelArgsForCall = append(fake.findCSVForPackageNameUnderChannelArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("FindCSVForPackageNameUnderChannel", []interface{}{arg1, arg2})
	fake.findCSVForPackageNameUnderChannelMutex.Unlock()
	if fake.FindCSVForPackageNameUnderChannelStub != nil {
		return fake.FindCSVForPackageNameUnderChannelStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findCSVForPackageNameUnderChannelReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSource) FindCSVForPackageNameUnderChannelCallCount() int {
	fake.findCSVForPackageNameUnderChannelMutex.RLock()
	defer fake.findCSVForPackageNameUnderChannelMutex.RUnlock()
	return len(fake.findCSVForPackageNameUnderChannelArgsForCall)
}

func (fake *FakeSource) FindCSVForPackageNameUnderChannelCalls(stub func(string, string) (*v1alpha1.ClusterServiceVersion, error)) {
	fake.findCSVForPackageNameUnderChannelMutex.Lock()
	defer fake.findCSVForPackageNameUnderChannelMutex.Unlock()
	fake.FindCSVForPackageNameUnderChannelStub = stub
}

func (fake *FakeSource) FindCSVForPackageNameUnderChannelArgsForCall(i int) (string, string) {
	fake.findCSVForPackageNameUnderChannelMutex.RLock()
	defer fake.findCSVForPackageNameUnderChannelMutex.RUnlock()
	argsForCall := fake.findCSVForPackageNameUnderChannelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSource) FindCSVForPackageNameUnderChannelReturns(result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findCSVForPackageNameUnderChannelMutex.Lock()
	defer fake.findCSVForPackageNameUnderChannelMutex.Unlock()
	fake.FindCSVForPackageNameUnderChannelStub = nil
	fake.findCSVForPackageNameUnderChannelReturns = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindCSVForPackageNameUnderChannelReturnsOnCall(i int, result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findCSVForPackageNameUnderChannelMutex.Lock()
	defer fake.findCSVForPackageNameUnderChannelMutex.Unlock()
	fake.FindCSVForPackageNameUnderChannelStub = nil
	if fake.findCSVForPackageNameUnderChannelReturnsOnCall == nil {
		fake.findCSVForPackageNameUnderChannelReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterServiceVersion
			result2 error
		})
	}
	fake.findCSVForPackageNameUnderChannelReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindReplacementCSVForName(arg1 string) (*v1alpha1.ClusterServiceVersion, error) {
	fake.findReplacementCSVForNameMutex.Lock()
	ret, specificReturn := fake.findReplacementCSVForNameReturnsOnCall[len(fake.findReplacementCSVForNameArgsForCall)]
	fake.findReplacementCSVForNameArgsForCall = append(fake.findReplacementCSVForNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindReplacementCSVForName", []interface{}{arg1})
	fake.findReplacementCSVForNameMutex.Unlock()
	if fake.FindReplacementCSVForNameStub != nil {
		return fake.FindReplacementCSVForNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findReplacementCSVForNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSource) FindReplacementCSVForNameCallCount() int {
	fake.findReplacementCSVForNameMutex.RLock()
	defer fake.findReplacementCSVForNameMutex.RUnlock()
	return len(fake.findReplacementCSVForNameArgsForCall)
}

func (fake *FakeSource) FindReplacementCSVForNameCalls(stub func(string) (*v1alpha1.ClusterServiceVersion, error)) {
	fake.findReplacementCSVForNameMutex.Lock()
	defer fake.findReplacementCSVForNameMutex.Unlock()
	fake.FindReplacementCSVForNameStub = stub
}

func (fake *FakeSource) FindReplacementCSVForNameArgsForCall(i int) string {
	fake.findReplacementCSVForNameMutex.RLock()
	defer fake.findReplacementCSVForNameMutex.RUnlock()
	argsForCall := fake.findReplacementCSVForNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSource) FindReplacementCSVForNameReturns(result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findReplacementCSVForNameMutex.Lock()
	defer fake.findReplacementCSVForNameMutex.Unlock()
	fake.FindReplacementCSVForNameStub = nil
	fake.findReplacementCSVForNameReturns = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindReplacementCSVForNameReturnsOnCall(i int, result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findReplacementCSVForNameMutex.Lock()
	defer fake.findReplacementCSVForNameMutex.Unlock()
	fake.FindReplacementCSVForNameStub = nil
	if fake.findReplacementCSVForNameReturnsOnCall == nil {
		fake.findReplacementCSVForNameReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterServiceVersion
			result2 error
		})
	}
	fake.findReplacementCSVForNameReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindReplacementCSVForPackageNameUnderChannel(arg1 string, arg2 string, arg3 string) (*v1alpha1.ClusterServiceVersion, error) {
	fake.findReplacementCSVForPackageNameUnderChannelMutex.Lock()
	ret, specificReturn := fake.findReplacementCSVForPackageNameUnderChannelReturnsOnCall[len(fake.findReplacementCSVForPackageNameUnderChannelArgsForCall)]
	fake.findReplacementCSVForPackageNameUnderChannelArgsForCall = append(fake.findReplacementCSVForPackageNameUnderChannelArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("FindReplacementCSVForPackageNameUnderChannel", []interface{}{arg1, arg2, arg3})
	fake.findReplacementCSVForPackageNameUnderChannelMutex.Unlock()
	if fake.FindReplacementCSVForPackageNameUnderChannelStub != nil {
		return fake.FindReplacementCSVForPackageNameUnderChannelStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findReplacementCSVForPackageNameUnderChannelReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSource) FindReplacementCSVForPackageNameUnderChannelCallCount() int {
	fake.findReplacementCSVForPackageNameUnderChannelMutex.RLock()
	defer fake.findReplacementCSVForPackageNameUnderChannelMutex.RUnlock()
	return len(fake.findReplacementCSVForPackageNameUnderChannelArgsForCall)
}

func (fake *FakeSource) FindReplacementCSVForPackageNameUnderChannelCalls(stub func(string, string, string) (*v1alpha1.ClusterServiceVersion, error)) {
	fake.findReplacementCSVForPackageNameUnderChannelMutex.Lock()
	defer fake.findReplacementCSVForPackageNameUnderChannelMutex.Unlock()
	fake.FindReplacementCSVForPackageNameUnderChannelStub = stub
}

func (fake *FakeSource) FindReplacementCSVForPackageNameUnderChannelArgsForCall(i int) (string, string, string) {
	fake.findReplacementCSVForPackageNameUnderChannelMutex.RLock()
	defer fake.findReplacementCSVForPackageNameUnderChannelMutex.RUnlock()
	argsForCall := fake.findReplacementCSVForPackageNameUnderChannelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSource) FindReplacementCSVForPackageNameUnderChannelReturns(result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findReplacementCSVForPackageNameUnderChannelMutex.Lock()
	defer fake.findReplacementCSVForPackageNameUnderChannelMutex.Unlock()
	fake.FindReplacementCSVForPackageNameUnderChannelStub = nil
	fake.findReplacementCSVForPackageNameUnderChannelReturns = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) FindReplacementCSVForPackageNameUnderChannelReturnsOnCall(i int, result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.findReplacementCSVForPackageNameUnderChannelMutex.Lock()
	defer fake.findReplacementCSVForPackageNameUnderChannelMutex.Unlock()
	fake.FindReplacementCSVForPackageNameUnderChannelStub = nil
	if fake.findReplacementCSVForPackageNameUnderChannelReturnsOnCall == nil {
		fake.findReplacementCSVForPackageNameUnderChannelReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterServiceVersion
			result2 error
		})
	}
	fake.findReplacementCSVForPackageNameUnderChannelReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) ListLatestCSVsForCRD(arg1 registry.CRDKey) ([]registry.CSVAndChannelInfo, error) {
	fake.listLatestCSVsForCRDMutex.Lock()
	ret, specificReturn := fake.listLatestCSVsForCRDReturnsOnCall[len(fake.listLatestCSVsForCRDArgsForCall)]
	fake.listLatestCSVsForCRDArgsForCall = append(fake.listLatestCSVsForCRDArgsForCall, struct {
		arg1 registry.CRDKey
	}{arg1})
	fake.recordInvocation("ListLatestCSVsForCRD", []interface{}{arg1})
	fake.listLatestCSVsForCRDMutex.Unlock()
	if fake.ListLatestCSVsForCRDStub != nil {
		return fake.ListLatestCSVsForCRDStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listLatestCSVsForCRDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSource) ListLatestCSVsForCRDCallCount() int {
	fake.listLatestCSVsForCRDMutex.RLock()
	defer fake.listLatestCSVsForCRDMutex.RUnlock()
	return len(fake.listLatestCSVsForCRDArgsForCall)
}

func (fake *FakeSource) ListLatestCSVsForCRDCalls(stub func(registry.CRDKey) ([]registry.CSVAndChannelInfo, error)) {
	fake.listLatestCSVsForCRDMutex.Lock()
	defer fake.listLatestCSVsForCRDMutex.Unlock()
	fake.ListLatestCSVsForCRDStub = stub
}

func (fake *FakeSource) ListLatestCSVsForCRDArgsForCall(i int) registry.CRDKey {
	fake.listLatestCSVsForCRDMutex.RLock()
	defer fake.listLatestCSVsForCRDMutex.RUnlock()
	argsForCall := fake.listLatestCSVsForCRDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSource) ListLatestCSVsForCRDReturns(result1 []registry.CSVAndChannelInfo, result2 error) {
	fake.listLatestCSVsForCRDMutex.Lock()
	defer fake.listLatestCSVsForCRDMutex.Unlock()
	fake.ListLatestCSVsForCRDStub = nil
	fake.listLatestCSVsForCRDReturns = struct {
		result1 []registry.CSVAndChannelInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) ListLatestCSVsForCRDReturnsOnCall(i int, result1 []registry.CSVAndChannelInfo, result2 error) {
	fake.listLatestCSVsForCRDMutex.Lock()
	defer fake.listLatestCSVsForCRDMutex.Unlock()
	fake.ListLatestCSVsForCRDStub = nil
	if fake.listLatestCSVsForCRDReturnsOnCall == nil {
		fake.listLatestCSVsForCRDReturnsOnCall = make(map[int]struct {
			result1 []registry.CSVAndChannelInfo
			result2 error
		})
	}
	fake.listLatestCSVsForCRDReturnsOnCall[i] = struct {
		result1 []registry.CSVAndChannelInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) ListServices() ([]v1alpha1.ClusterServiceVersion, error) {
	fake.listServicesMutex.Lock()
	ret, specificReturn := fake.listServicesReturnsOnCall[len(fake.listServicesArgsForCall)]
	fake.listServicesArgsForCall = append(fake.listServicesArgsForCall, struct {
	}{})
	fake.recordInvocation("ListServices", []interface{}{})
	fake.listServicesMutex.Unlock()
	if fake.ListServicesStub != nil {
		return fake.ListServicesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listServicesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSource) ListServicesCallCount() int {
	fake.listServicesMutex.RLock()
	defer fake.listServicesMutex.RUnlock()
	return len(fake.listServicesArgsForCall)
}

func (fake *FakeSource) ListServicesCalls(stub func() ([]v1alpha1.ClusterServiceVersion, error)) {
	fake.listServicesMutex.Lock()
	defer fake.listServicesMutex.Unlock()
	fake.ListServicesStub = stub
}

func (fake *FakeSource) ListServicesReturns(result1 []v1alpha1.ClusterServiceVersion, result2 error) {
	fake.listServicesMutex.Lock()
	defer fake.listServicesMutex.Unlock()
	fake.ListServicesStub = nil
	fake.listServicesReturns = struct {
		result1 []v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) ListServicesReturnsOnCall(i int, result1 []v1alpha1.ClusterServiceVersion, result2 error) {
	fake.listServicesMutex.Lock()
	defer fake.listServicesMutex.Unlock()
	fake.ListServicesStub = nil
	if fake.listServicesReturnsOnCall == nil {
		fake.listServicesReturnsOnCall = make(map[int]struct {
			result1 []v1alpha1.ClusterServiceVersion
			result2 error
		})
	}
	fake.listServicesReturnsOnCall[i] = struct {
		result1 []v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeSource) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allPackagesMutex.RLock()
	defer fake.allPackagesMutex.RUnlock()
	fake.findCRDByKeyMutex.RLock()
	defer fake.findCRDByKeyMutex.RUnlock()
	fake.findCSVByNameMutex.RLock()
	defer fake.findCSVByNameMutex.RUnlock()
	fake.findCSVForPackageNameUnderChannelMutex.RLock()
	defer fake.findCSVForPackageNameUnderChannelMutex.RUnlock()
	fake.findReplacementCSVForNameMutex.RLock()
	defer fake.findReplacementCSVForNameMutex.RUnlock()
	fake.findReplacementCSVForPackageNameUnderChannelMutex.RLock()
	defer fake.findReplacementCSVForPackageNameUnderChannelMutex.RUnlock()
	fake.listLatestCSVsForCRDMutex.RLock()
	defer fake.listLatestCSVsForCRDMutex.RUnlock()
	fake.listServicesMutex.RLock()
	defer fake.listServicesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSource) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ registry.Source = new(FakeSource)
