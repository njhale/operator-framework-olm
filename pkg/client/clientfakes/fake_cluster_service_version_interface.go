// Code generated by counterfeiter. DO NOT EDIT.
package clientfakes

import (
	"sync"

	"github.com/coreos-inc/alm/pkg/apis/clusterserviceversion/v1alpha1"
	"github.com/coreos-inc/alm/pkg/client"
)

type FakeClusterServiceVersionInterface struct {
	UpdateCSVStub        func(csv *v1alpha1.ClusterServiceVersion) (result *v1alpha1.ClusterServiceVersion, err error)
	updateCSVMutex       sync.RWMutex
	updateCSVArgsForCall []struct {
		csv *v1alpha1.ClusterServiceVersion
	}
	updateCSVReturns struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	updateCSVReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	GetCSVByNameStub        func(namespace string, name string) (result *v1alpha1.ClusterServiceVersion, err error)
	getCSVByNameMutex       sync.RWMutex
	getCSVByNameArgsForCall []struct {
		namespace string
		name      string
	}
	getCSVByNameReturns struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	getCSVByNameReturnsOnCall map[int]struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}
	CreateCSVStub        func(csv *v1alpha1.ClusterServiceVersion) (err error)
	createCSVMutex       sync.RWMutex
	createCSVArgsForCall []struct {
		csv *v1alpha1.ClusterServiceVersion
	}
	createCSVReturns struct {
		result1 error
	}
	createCSVReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClusterServiceVersionInterface) UpdateCSV(csv *v1alpha1.ClusterServiceVersion) (result *v1alpha1.ClusterServiceVersion, err error) {
	fake.updateCSVMutex.Lock()
	ret, specificReturn := fake.updateCSVReturnsOnCall[len(fake.updateCSVArgsForCall)]
	fake.updateCSVArgsForCall = append(fake.updateCSVArgsForCall, struct {
		csv *v1alpha1.ClusterServiceVersion
	}{csv})
	fake.recordInvocation("UpdateCSV", []interface{}{csv})
	fake.updateCSVMutex.Unlock()
	if fake.UpdateCSVStub != nil {
		return fake.UpdateCSVStub(csv)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateCSVReturns.result1, fake.updateCSVReturns.result2
}

func (fake *FakeClusterServiceVersionInterface) UpdateCSVCallCount() int {
	fake.updateCSVMutex.RLock()
	defer fake.updateCSVMutex.RUnlock()
	return len(fake.updateCSVArgsForCall)
}

func (fake *FakeClusterServiceVersionInterface) UpdateCSVArgsForCall(i int) *v1alpha1.ClusterServiceVersion {
	fake.updateCSVMutex.RLock()
	defer fake.updateCSVMutex.RUnlock()
	return fake.updateCSVArgsForCall[i].csv
}

func (fake *FakeClusterServiceVersionInterface) UpdateCSVReturns(result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.UpdateCSVStub = nil
	fake.updateCSVReturns = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceVersionInterface) UpdateCSVReturnsOnCall(i int, result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.UpdateCSVStub = nil
	if fake.updateCSVReturnsOnCall == nil {
		fake.updateCSVReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterServiceVersion
			result2 error
		})
	}
	fake.updateCSVReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceVersionInterface) GetCSVByName(namespace string, name string) (result *v1alpha1.ClusterServiceVersion, err error) {
	fake.getCSVByNameMutex.Lock()
	ret, specificReturn := fake.getCSVByNameReturnsOnCall[len(fake.getCSVByNameArgsForCall)]
	fake.getCSVByNameArgsForCall = append(fake.getCSVByNameArgsForCall, struct {
		namespace string
		name      string
	}{namespace, name})
	fake.recordInvocation("GetCSVByName", []interface{}{namespace, name})
	fake.getCSVByNameMutex.Unlock()
	if fake.GetCSVByNameStub != nil {
		return fake.GetCSVByNameStub(namespace, name)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getCSVByNameReturns.result1, fake.getCSVByNameReturns.result2
}

func (fake *FakeClusterServiceVersionInterface) GetCSVByNameCallCount() int {
	fake.getCSVByNameMutex.RLock()
	defer fake.getCSVByNameMutex.RUnlock()
	return len(fake.getCSVByNameArgsForCall)
}

func (fake *FakeClusterServiceVersionInterface) GetCSVByNameArgsForCall(i int) (string, string) {
	fake.getCSVByNameMutex.RLock()
	defer fake.getCSVByNameMutex.RUnlock()
	return fake.getCSVByNameArgsForCall[i].namespace, fake.getCSVByNameArgsForCall[i].name
}

func (fake *FakeClusterServiceVersionInterface) GetCSVByNameReturns(result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.GetCSVByNameStub = nil
	fake.getCSVByNameReturns = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceVersionInterface) GetCSVByNameReturnsOnCall(i int, result1 *v1alpha1.ClusterServiceVersion, result2 error) {
	fake.GetCSVByNameStub = nil
	if fake.getCSVByNameReturnsOnCall == nil {
		fake.getCSVByNameReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ClusterServiceVersion
			result2 error
		})
	}
	fake.getCSVByNameReturnsOnCall[i] = struct {
		result1 *v1alpha1.ClusterServiceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClusterServiceVersionInterface) CreateCSV(csv *v1alpha1.ClusterServiceVersion) (err error) {
	fake.createCSVMutex.Lock()
	ret, specificReturn := fake.createCSVReturnsOnCall[len(fake.createCSVArgsForCall)]
	fake.createCSVArgsForCall = append(fake.createCSVArgsForCall, struct {
		csv *v1alpha1.ClusterServiceVersion
	}{csv})
	fake.recordInvocation("CreateCSV", []interface{}{csv})
	fake.createCSVMutex.Unlock()
	if fake.CreateCSVStub != nil {
		return fake.CreateCSVStub(csv)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createCSVReturns.result1
}

func (fake *FakeClusterServiceVersionInterface) CreateCSVCallCount() int {
	fake.createCSVMutex.RLock()
	defer fake.createCSVMutex.RUnlock()
	return len(fake.createCSVArgsForCall)
}

func (fake *FakeClusterServiceVersionInterface) CreateCSVArgsForCall(i int) *v1alpha1.ClusterServiceVersion {
	fake.createCSVMutex.RLock()
	defer fake.createCSVMutex.RUnlock()
	return fake.createCSVArgsForCall[i].csv
}

func (fake *FakeClusterServiceVersionInterface) CreateCSVReturns(result1 error) {
	fake.CreateCSVStub = nil
	fake.createCSVReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterServiceVersionInterface) CreateCSVReturnsOnCall(i int, result1 error) {
	fake.CreateCSVStub = nil
	if fake.createCSVReturnsOnCall == nil {
		fake.createCSVReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createCSVReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClusterServiceVersionInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.updateCSVMutex.RLock()
	defer fake.updateCSVMutex.RUnlock()
	fake.getCSVByNameMutex.RLock()
	defer fake.getCSVByNameMutex.RUnlock()
	fake.createCSVMutex.RLock()
	defer fake.createCSVMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClusterServiceVersionInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.ClusterServiceVersionInterface = new(FakeClusterServiceVersionInterface)
